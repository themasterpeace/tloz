   var inverted = this.chart.inverted, crisp = this.borderWidth % 2 / 2;
        // Distort the points to reflect z dimension
        this.points.forEach(function (point, i) {
            var left, right;
            if (xAxis.variwide) {
                left = this.postTranslate(i, point.shapeArgs.x, point);
                right = this.postTranslate(i, point.shapeArgs.x +
                    point.shapeArgs.width);
                // For linear or datetime axes, the variwide column should
                // start with X and extend Z units, without modifying the
                // axis.
            }
            else {
                left = point.plotX;
                right = xAxis.translate(point.x + point.z, 0, 0, 0, 1);
            }
            if (this.options.crisp) {
                left = Math.round(left) - crisp;
                right = Math.round(right) - crisp;
            }
            point.shapeArgs.x = left;
            point.shapeArgs.width = Math.max(right - left, 1);
            // Crosshair position (#8083)
            point.plotX = (left + right) / 2;
            // Adjust the tooltip position
            if (!inverted) {
                point.tooltipPos[0] =
                    point.shapeArgs.x +
                        point.shapeArgs.width / 2;
            }
            else {
                point.tooltipPos[1] =
                    xAxis.len - point.shapeArgs.x -
                        point.shapeArgs.width / 2;
            }
        }, this);
        if (this.options.stacking) {
            this.correctStackLabels();
        }
    },
    // Function that corrects stack labels positions
    correctStackLabels: function () {
        var series = this, options = series.options, yAxis = series.yAxis, pointStack, pointWidth, stack, xValue;
        series.points.forEach(function (point) {
            xValue = point.x;
            pointWidth = point.shapeArgs.width;
            stack = yAxis.stacking.stacks[(series.negStacks &&
                point.y < (options.startFromThreshold ?
                    0 :
                    options.threshold) ?
                '-' :
                '') + series.stackKey];
            if (stack) {
                pointStack = stack[xValue];
                if (pointStack && !point.isNull) {
                    pointStack.setOffset(-(pointWidth / 2) || 0, pointWidth || 0, void 0, void 0, point.plotX);
                }
            }
        });
    }
    // Point functions
}, {
    isValid: function () {
        return isNumber(this.y) && isNumber(this.z);
    }
});
H.Tick.prototype.postTranslate = function (xy, xOrY, index) {
    var axis = this.axis, pos = xy[xOrY] - axis.pos;
    if (!axis.horiz) {
        pos = axis.len - pos;
    }
    pos = axis.series[0].postTranslate(index, pos);
    if (!axis.horiz) {
        pos = axis.len - pos;
    }
    xy[xOrY] = axis.pos + pos;
};
/* eslint-disable no-invalid-this */
// Same width as the category (#8083)
addEvent(H.Axis, 'afterDrawCrosshair', function (e) {
    if (this.variwide && this.cross) {
        this.cross.attr('stroke-w